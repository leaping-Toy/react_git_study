# 3.6 리액트 내장 훅 살펴보기

## 3.6.1 Consumer 컴포넌트 없이 콘텍스트 사용하가: useContext

```javascript
const UserContext = React.createContext();
const user = { name: 'mike', age: 23 };

function ParentComponent() {
    // 부모 컴포넌트에서는 Provider 컴포넌트를 통해서 데이터를 전달
    return (
        <UserContext.Provider value={user}>
            <ChileComponent />
        </UserContext.Provider>
    );
}

function ChildComponent() { 
    // 자식 컴포넌트 에서는 Consumer 컴포넌트를 통해서 데이터 사용
    // ...
    return (
        <div>
            <UserContext.Consumer>
                {user => (
                    <>
                        <p>{`name is ${user.name}`}</p>
                        <p>{`age is ${user.age}`}</p>
                    </>
                )}
            </UserContext.Consumer>
        </div>
    );
}

// 다음과 같이 useContext 훅을 사용하면 return문 외에서도
// 콘텍스트 데이터에 접근할 수 있다.
function ChildComponent() { 
    const User = userContext(UserContext);
    console.log(`user: ${user.name}, ${user.age}`);
    // ...
}
```

## 3.6.2 렌더링과 무관한 값 저장하기: useRef

```javascript
import React, { useState, useRef, useEffect } from 'react';

funtion Profile() {
    const [age, setAge] = useState(20);
    const prevAgeRef = useRef(20);
    // age 이전 상탯값을 저장하기 위한 용도로 useRef 훅을 사용한다.

    useEffect(
        () => {
        prevAgeRef.current = age;
        },
        [age],
    );
    // age값이 변경되면 그 값을 prevAgeRef에 저장한다

    const prevAge = prevAgeRef.current;
    const text = age === prevAge ? 'same' : age > prevAge ? 'older' : 'younger';
    // age의 이전 상탯값을 이용한다

    return (
        <div>
            <p>{`age ${age} is ${text} than age ${prevAge}`}</p>
            <button
                onClick={() => {
                    const age = Math.floor(Math.random() * 50 + 1);
                    setAge(age);
                }}
            >
                나이 변경
            </button>
        </div>
    ); 
    // age가 변경돼서 다시 렌더링할 때,
    // 위의 prevAge 는 age의 이전상탯값을 나타낸다
    // 그리고 렌더링이 끝나면 prevAgeRef는 다시 최신 상탯값으로 변경!
}
```

## 3.6.3 메모이제이션 훅: useMemo, useCallback

### **useMemo**
```javascript
import React, { useMemo } from 'react';
import { runExpensiveJob } from './util';

function MyComponent({ v1, v2 }) {
    const value = useMemo(() => runExpensiveJob(v1, v2), [v1, v2]);
    // useMemo 훅의 첫 번째 매개변수로 함수를 입력한다.
    // useMemo 훅은 이 함수가 반환한 값을 기억한다.
    // useMemo 훅의 두 번째 매개변수는 의존성 배열이다.
    // 의존성 배열이 변경되지 않으면 이전에 반환된 값을 재사용한다.
    // 만약 배열이 변경됐으면 첫 번째 매개변수로 입력된 함수를 실행하고
    // 그 반환값을 기억한다.


    return <p>{`value is ${value}`}</p>
}
```
> useMemo 훅은 계산량이 많은 함수의 반환값을 재활용하는 용도로 사용된다!

### **useCallback**
```javascript
import React, { useState } from 'react';
import { saveToServer } from './api'
import UserEdit from './UserEdit'

function Profile() {
    const [name, setName] = useState('');
    const [age, setAge] = useState(0);
    return (
        <div>
            <p>{`name is ${name}`}</p>
            <p>{`age is ${age}`}</p>
            <UserEdit
                onSave={() => saveToServer(name, age)}
                setName={setName}
                setAge={setAge}
            />
        </div>
    );
    // Profile 컴포넌트가 렌더링될 때마다 
    // onSave 속성값으로 새로운 함수가 입력된다.
    // 따라서 UserEdit 컴포넌트에서 React.memo를 사용해도
    // onSave 속성값이 항상 변경되고 불필요한 렌더링 발생!
    // onSave 속성값은 name이나 age값이 변경되지 않으면
    // 항상 같아야한다!!
}


// useCallback 훅 사용하기
function Profile() {
    const [name, setName] = useState('');
    const [age, setAge] = useState(0);
    const onSave = useCallback(() => saveToServer(name,age), [name, age]);
    // 이전에 onSave 속성값으로 전달했던 것과 같은 함수를
    // useCallback 훅의 첫 번째 매개변수로 입력!

    return (
        <div>
            <p>{`name is ${name}`}</p>
            <p>{`age is ${age}`}</p>
            <UserEdit
                onSave={onSave}
                setName={setName}
                setAge={setAge}
            />
        </div>
    );
}


```



